# Generated by Django 4.2.13 on 2024-05-28 10:09

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('blog', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='post',
            name='exerpt',
            field=models.TextField(blank=True),
        ),
    ]

# The operations list in 0001_initial.py tells Django what changes to make to the database. 
# In this case, the changes are to create a model named Post. 
# The fields list contains exactly the same field names and types that you created in your model in models.py.

# Inside the file:
# You will see a dependencies list. This list contains tuples that consist of the app name, 
# in this case blog and the migrations that must be applied before this one can be. 
# In our case, that is 0001_initial, the file we just looked at. 
# This dependency is logical because we cannot add a field to a model if the model does not yet exist.

# The operations list then carries out the changes to the database. In this migration file, we are adding a field.
#  We only have one operation in our list, but if we were adding multiple fields or even another model,
#  then they would appear here too.

# makemigrations creates the migrations file locally, 
# whereas the changes are applied to the database when you run the migrate command.

#Every time we run the migrate command, 
# Django follows our LEGO building instructions to build or modify our database model. 
# We need to make migrations and migrate every time we change a database model.

# It follows that it's a good idea to keep our migrations quite tightly focused, as we do with our git commits.
#  Don't add or change too many features all at once, but make migrations after one or more smaller changes.