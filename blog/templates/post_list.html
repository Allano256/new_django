<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Views Part 1</title>
</head>

<body>
    <h1>Posts list</h1>
    {% for post in object_list %}
    <h2>{{post.title}}</h2>
    <p>{{post.excerpt}}</p>
    <p>Author: {{post.author}}</p>
    {% endfor %}
</body>

</html>

<!-- 
    1. The advantage to using class-based generic views is that they are very terse, 
    i.e. you do not need to add the HTML template name or list which posts you want to see. Letâ€™s add these optional lines of code in the PostView class,
     ready for you to modify in the next topic.
     2. Generic views are beneficial for dealing with repetitive full-stack coding tasks such as displaying database contents to a webpage.
      It handles the most common use cases in web app development.

    3. What is a queryset?
      When we first created our view, the only line we added was model = Post. 
      This line told Django to use all of the records from the Post model in our ListView. 
      This created what is called a queryset, 
      which represents a collection of records from your database.
    4.A filter works just like the filter on your coffee machine. It stops certain things from getting through - coffee grounds, for example. 
    It only allows through the things that we want, such as, delicious coffee.
In the code, we asked Django only to allow posts with the author field set to 1 through the filter. Everything else was filtered out. 
Filters are a powerful way for us to perform queries on our database

5.Another method that we can use is order_by.
 This method allows us to specify the ordering of our records.
  If we wanted to display all of our posts ordered from the earliest date to the most recent,
 we could do this:
-->